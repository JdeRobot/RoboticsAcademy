// **********************************************************************
//
// Copyright (c) 2003-2017 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.6.4
//
// <auto-generated>
//
// Generated from file `visualization.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

(function(module, require, exports)
{
    var Ice = require("ice").Ice;
    var __M = Ice.__M;
    var jderobot = __M.require(module,
    [
        "common",
        "primitives"
    ]).jderobot;

    var Slice = Ice.Slice;

    jderobot.Color = Slice.defineStruct(
        function(r, g, b)
        {
            this.r = r !== undefined ? r : 0.0;
            this.g = g !== undefined ? g : 0.0;
            this.b = b !== undefined ? b : 0.0;
        },
        false,
        function(__os)
        {
            __os.writeFloat(this.r);
            __os.writeFloat(this.g);
            __os.writeFloat(this.b);
        },
        function(__is)
        {
            this.r = __is.readFloat();
            this.g = __is.readFloat();
            this.b = __is.readFloat();
        },
        12, 
        true);

    jderobot.RGBSegment = Slice.defineStruct(
        function(seg, c)
        {
            this.seg = seg !== undefined ? seg : new jderobot.Segment();
            this.c = c !== undefined ? c : new jderobot.Color();
        },
        false,
        function(__os)
        {
            jderobot.Segment.write(__os, this.seg);
            jderobot.Color.write(__os, this.c);
        },
        function(__is)
        {
            this.seg = jderobot.Segment.read(__is, this.seg);
            this.c = jderobot.Color.read(__is, this.c);
        },
        36, 
        true);
    Slice.defineSequence(jderobot, "SegmentsHelper", "jderobot.RGBSegment", true);
    Slice.defineSequence(jderobot, "PointsHelper", "jderobot.RGBPoint", true);

    jderobot.bufferSegments = Slice.defineStruct(
        function(buffer, refresh)
        {
            this.buffer = buffer !== undefined ? buffer : null;
            this.refresh = refresh !== undefined ? refresh : false;
        },
        false,
        function(__os)
        {
            jderobot.SegmentsHelper.write(__os, this.buffer);
            __os.writeBool(this.refresh);
        },
        function(__is)
        {
            this.buffer = jderobot.SegmentsHelper.read(__is);
            this.refresh = __is.readBool();
        },
        2, 
        false);

    jderobot.bufferPoints = Slice.defineStruct(
        function(buffer, refresh)
        {
            this.buffer = buffer !== undefined ? buffer : null;
            this.refresh = refresh !== undefined ? refresh : false;
        },
        false,
        function(__os)
        {
            jderobot.PointsHelper.write(__os, this.buffer);
            __os.writeBool(this.refresh);
        },
        function(__is)
        {
            this.buffer = jderobot.PointsHelper.read(__is);
            this.refresh = __is.readBool();
        },
        2, 
        false);


    /**
     * Interface to the Visualization interaction.
     **/
    jderobot.Visualization = Slice.defineObject(
        undefined,
        Ice.Object, undefined, 1,
        [
            "::Ice::Object",
            "::jderobot::Visualization"
        ],
        -1, undefined, undefined, false);

    jderobot.VisualizationPrx = Slice.defineProxy(Ice.ObjectPrx, jderobot.Visualization.ice_staticId, undefined);

    Slice.defineOperations(jderobot.Visualization, jderobot.VisualizationPrx,
    {
        "drawSegment": [, , , , , , [[jderobot.bufferSegments]], , , , ],
        "getSegment": [, , , , , [jderobot.bufferSegments], , , , , ],
        "drawPoint": [, , , , , , [[jderobot.bufferPoints]], , , , ],
        "getPoints": [, , , , , [jderobot.bufferPoints], , , , , ],
        "clearAll": [, , , , , , , , , , ]
    });
    exports.jderobot = jderobot;
}
(typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? module : undefined,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? require : this.Ice.__require,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? exports : this));
